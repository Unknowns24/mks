package queues

import (
	"github.com/cenkalti/backoff/v4"
)

type queueMessage struct {
	event        string
	exchange     string
	deliveryMode uint8
	messageData  map[string]interface{}
}

var queuedMessage []queueMessage
var handlerStarted bool

func handlePublisConnErr(message queueMessage) {
	queuedMessage = append(queuedMessage, message)

	if !handlerStarted {
		go startHandler()
	}
}

func startHandler() {
	handlerStarted = true

	// An operation that may fail.
	operation := func() error {
		var successMessages []int
		for i, msg := range queuedMessage { // iterate all messages
			err := SendMessage(msg.exchange, msg.event, msg.deliveryMode, false, msg.messageData) // try to send it
			if err != nil { // if error return the error
				return err
			}

			successMessages = append(successMessages, i) // if succeed add msg indes to a `successMessages` int slice
		}
		
		var newSlice []queueMessage
		for i, msg := range queuedMessage { // iterate all messages
			messageIsSuccess := false

			for _, index := range successMessages { // iterate all success messages
				if i == index { // if messages is success
					messageIsSuccess = true // set messageIsSucess
					break
				}
			}

			if !messageIsSuccess { // if the message is not success keep it in the queuedMessage array
				newSlice = append(newSlice, msg) 
			}
		}

		queuedMessage = newSlice // redeclare the queuedMessage array with messages wich still unsuccessfully sended

		return nil
	}

	// initialize a loop until operation succeed
	for {
		err := backoff.Retry(operation, backoff.NewExponentialBackOff())
		if err == nil {
			handlerStarted = false
			break
		}
	}
}
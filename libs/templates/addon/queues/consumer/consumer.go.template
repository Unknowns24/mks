package queues

import (
	"context"
	"%PACKAGE_NAME%/src/utils"
	"encoding/json"
	"fmt"

	amqp "github.com/rabbitmq/amqp091-go"
)

func InitialiceQueue() error {
	// Initializing Advanced message queuing protocol connection
	conn, err := amqp.Dial(fmt.Sprintf("amqp://%s:%s@%s/", utils.ENV.RABBIT_USER, utils.ENV.RABBIT_PASS, utils.ENV.RABBIT_HOST))

	if err != nil {
		return fmt.Errorf("[ERROR] Fatal Error: Cannot initialize RabbitMQ connection...\n %s", err.Error())
	}

	go func() {
		<-conn.NotifyClose(make(chan *amqp.Error)) // Expecting connection close
		handleConnectionLost(1, 32)
	}()

	defer conn.Close()

	ch, err := conn.Channel()

	if err != nil {
		return fmt.Errorf("[ERROR] Fatal Error: Cannot open a channel connection...\n %s", err.Error())
	}

	defer ch.Close()

	// Declaring the Queue
	queue, err := ch.QueueDeclare(utils.ENV.RABBIT_QUEUE, true, false, false, false, nil)

	if err != nil {
		return fmt.Errorf("[ERROR] Fatal Error: Cannot declare the Queue...\n %s", err.Error())
	}

	// Declare exchange
	err = ch.ExchangeDeclare(utils.ENV.RABBIT_EXCHANGE, amqp.ExchangeDirect, true, false, false, false, nil)

	if err != nil {
		return fmt.Errorf("[ERROR] Fatal Error: Cannot declare the exchange...\n %s", err.Error())
	}

	// Bind queue
	err = ch.QueueBind(utils.ENV.RABBIT_QUEUE, "", utils.ENV.RABBIT_EXCHANGE, false, nil)

	if err != nil {
		return fmt.Errorf("[ERROR] Fatal Error: Cannot bind the queue with the exchange...\n %s", err.Error())
	}

	// Consume channel messages
	chDelivery, err := ch.Consume(queue.Name, "", false, false, false, false, nil)
	if err != nil {
		return fmt.Errorf("[ERROR] Fatal Error: Cannot consume channel messages...\n %s", err.Error())
	}

	noStop := make(chan bool)

	fmt.Println("[*] Server started and waiting for messages!")

	go func() {
		for message := range chDelivery {
			fmt.Println("[*] Message Received")

			parseMessage(message)
		}
	}()

	<-noStop

	return nil
}

func parseMessage(message amqp.Delivery) {
	var messageInfo map[string]interface{}

	// Parsing message global structure
	err := json.Unmarshal(message.Body, &messageInfo)

	if err != nil || messageInfo == nil {
		fmt.Println("[x] Unreadable message")
		return
	}

	// if message hasn't got identifier
	if messageInfo["global_id"] == nil {
		message.Nack(false, false)
		return
	}

	// Check if the global content variables exists in the message
	if messageInfo["message"] == nil || messageInfo["event"] == nil {
		message.Nack(false, false)
		fmt.Println("[x] Unreadable message content, queue msg id: " + messageInfo["global_id"].(string))
		return
	}

	// Parsing message data structure
	/* 
		switch messageInfo["event"] {
		
		case "email.send":
			controllers.SendEmail(message, messageInfo["global_id"].(string))

		default:
			message.Nack(false, false)
			fmt.Println("[x] Unexpected event: " + messageInfo["event"].(string) + " on queue msg " + messageInfo["global_id"].(string))

		}
	*/
}